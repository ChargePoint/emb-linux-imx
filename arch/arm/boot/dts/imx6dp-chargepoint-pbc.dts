/*
 * Copyright 2013 Boundary Devices
 * Copyright 2012 Freescale Semiconductor, Inc.
 * Copyright 2011 Linaro Ltd.
 *
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

/dts-v1/;

#include "imx6q.dtsi"
#include "imx6qp.dtsi"
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>

/*
 * Refer emb-cpnk.git/kernel-imx -- imx6qp-cpnk.dtsi, imx6qp-sabresd-cpnk.dts
 */

/ {
        model = "ChargePoint PBC Board";
        compatible = "fsl,imx6q-sabresd", "fsl,imx6q", "fsl,imx6q-pbc";
        memory: memory {
                reg = <0x10000000 0x80000000>;
        };
};

&iomuxc {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_hog>;
        iomuxc_imx6q_pbc: iomuxc-imx6q-pbc-grp {
                status = "okay";
        };
};

&iomuxc_imx6q_pbc {
        pinctrl_hog: hoggrp {
                fsl,pins = <
                    MX6QDL_PAD_NANDF_CS0__GPIO6_IO11            0x1b0b0 /* ACCEL_INT_B */
                    MX6QDL_PAD_NANDF_CS1__GPIO6_IO14            0x1b0b0 /* MAG_INT_B */
                    MX6QDL_PAD_NANDF_CS2__GPIO6_IO15            0x1b0b0 /* MAG_DRDY */
                    MX6QDL_PAD_NANDF_D0__GPIO2_IO00             0x1b0b0 /* GPIO2_0 */
                    MX6QDL_PAD_NANDF_D1__GPIO2_IO01             0x1b0b0 /* GPIO2_1 */
                    MX6QDL_PAD_NANDF_D2__GPIO2_IO02             0x1b0b0 /* GPIO2_2 */
                    MX6QDL_PAD_NANDF_D3__GPIO2_IO03             0x1b0b0 /* GPIO2_3 */
                    MX6QDL_PAD_NANDF_D6__GPIO2_IO06             0x1b0b0 /* PS2SOC_PG */
                    MX6QDL_PAD_NANDF_ALE__GPIO6_IO08            0x1b0b0 /* SOC_SURGE_DET1 */
                    MX6QDL_PAD_NANDF_CLE__GPIO6_IO07            0x1b0b0 /* SOC_SURGE_DET2 */
                    MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09           0x1b0b0 /* SOC_SURGE_DET3 */
                    MX6QDL_PAD_NANDF_RB0__GPIO6_IO10            0x1b0b0 /* SOC_SURGE_DET4 */
                    MX6QDL_PAD_NANDF_D4__GPIO2_IO04             0x1b0b0 /* SOC_SURGE_DET5 */

                    MX6QDL_PAD_EIM_D16__GPIO3_IO16              0x1b0b0 /* RTD_DRDYn */
                    MX6QDL_PAD_EIM_D19__GPIO3_IO19              0x1b0b0 /* RTD_START_SYNC */
                    MX6QDL_PAD_EIM_D20__GPIO3_IO20              0x1b0b0 /* PM_RESET_N */
                    MX6QDL_PAD_EIM_D23__GPIO3_IO23              0x1b0b0 /* SOC_THER_SW1 */
                    MX6QDL_PAD_EIM_D24__GPIO3_IO24              0x1b0b0 /* SOC_THER_SW2 */
                    MX6QDL_PAD_EIM_D29__GPIO3_IO29              0x1b0b0 /* PMIC_INT_B */
                    MX6QDL_PAD_EIM_D30__GPIO3_IO30              0x1b0b0 /* SOC_THER_SW3 */
                    MX6QDL_PAD_EIM_D31__GPIO3_IO31              0x1b0b0 /* SOC_THER_SW4 */

                    MX6QDL_PAD_SD4_DAT6__GPIO2_IO14             0x1b0b0 /* FAN_TACH_DSP0 */
                    MX6QDL_PAD_SD4_DAT7__GPIO2_IO15             0x1b0b0 /* FAN_TACH_DSP1 */

                    MX6QDL_PAD_GPIO_0__GPIO1_IO00               0x1b0b0 /* PM_INT_IN */
                    MX6QDL_PAD_GPIO_2__GPIO1_IO02               0x1b0b0 /* ETH_PWR_EN */
                    MX6QDL_PAD_GPIO_4__GPIO1_IO04               0x1b0b0 /* SOC_FLOAT_TRIP1 */
                    MX6QDL_PAD_GPIO_5__GPIO1_IO05               0x1b0b0 /* SOC_FLOAT_TRIP2 */
                    MX6QDL_PAD_GPIO_6__GPIO1_IO06               0x1b0b0 /* SER_PWR_EN */
                    MX6QDL_PAD_GPIO_16__GPIO7_IO11              0x1b0b0 /* SOC_REED1 */
                    MX6QDL_PAD_GPIO_17__GPIO7_IO12              0x1b0b0 /* SOC_REED2 */
                    MX6QDL_PAD_GPIO_18__GPIO7_IO13              0x1b0b0 /* SOC_REED3 */
                    MX6QDL_PAD_GPIO_19__GPIO4_IO05              0x1b0b0 /* SOC_REED4 */

                    MX6QDL_PAD_DISP0_DAT18__GPIO5_IO12          0x1b0b0 /* I2C PMIC ENABLE */
                    MX6QDL_PAD_GPIO_9__GPIO1_IO09               0x1b0b0 /* SOC_LED */
                    MX6QDL_PAD_KEY_ROW2__GPIO4_IO11             0x1b0b0 /* SOC_LED1 */
                >;
        };

        pinctrl_enet: enetgrp {
                fsl,pins = <
                    MX6QDL_PAD_ENET_MDIO__ENET_MDIO             0x1b0b0
                    MX6QDL_PAD_ENET_MDC__ENET_MDC               0x1b0b0
                    MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN           0x1b0b0
                    MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER           0x1b0b0
                    MX6QDL_PAD_GPIO_3__GPIO1_IO03               0x1b0b0 /* PHY_RSTn */

                    MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b030
                    MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b030
                    MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b030
                    MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b030
                    MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b030
                    MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b030
                    MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b030
                    MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b030
                    MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b030
                    MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b030
                    MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b030
                    MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b030
                >;
        };

        pinctrl_flexcan1: flexcan1grp {
                fsl,pins = <
                    MX6QDL_PAD_GPIO_7__FLEXCAN1_TX              0x1b0b0
                    MX6QDL_PAD_GPIO_8__FLEXCAN1_RX              0x1b0b0
                >;
        };

        pinctrl_flexcan2: flexcan2grp {
                fsl,pins = <
                    MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX            0x1b0b0
                    MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX            0x1b0b0
                >;
        };

        pinctrl_i2c1: i2c1grp {
                fsl,pins = <
                    MX6QDL_PAD_CSI0_DAT9__I2C1_SCL              0x4001b0b1
                    MX6QDL_PAD_CSI0_DAT8__I2C1_SDA              0x4001b0b1
                >;
        };

        pinctrl_i2c2: i2c2grp {
                fsl,pins = <
                    MX6QDL_PAD_KEY_COL3__I2C2_SCL               0x4001b0b1
                    MX6QDL_PAD_KEY_ROW3__I2C2_SDA               0x4001b0b1
                >;
        };

        pinctrl_i2c3: i2c3grp {
                fsl,pins = <
                    MX6QDL_PAD_EIM_D17__I2C3_SCL                0x4001b0b1
                    MX6QDL_PAD_EIM_D18__I2C3_SDA                0x4001b0b1
                >;
        };

        pinctrl_uart1: uart1grp { /* DBG Console */
                fsl,pins = <
                    MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA        0x1b0b1
                    MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA        0x1b0b1
                >;
        };

        pinctrl_uart2: uart2grp { /* RS485 */
                fsl,pins = <
                    MX6QDL_PAD_EIM_D25__GPIO3_IO25              0x1b0b1
                    MX6QDL_PAD_EIM_D26__UART2_TX_DATA           0x1b0b1
                    MX6QDL_PAD_EIM_D27__UART2_RX_DATA           0x1b0b1
                    MX6QDL_PAD_EIM_D28__GPIO3_IO28              0x1b0b1
                >;
        };

        pinctrl_ecspi1: ecspi1grp {
                fsl,pins = <
                    MX6QDL_PAD_KEY_COL1__ECSPI1_MISO            0x100b1
                    MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI            0x100b1
                    MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK            0x100b1
                    MX6QDL_PAD_KEY_ROW1__GPIO4_IO09             0x1b0b0
                >;
        };

        pinctrl_usdhc3: usdhc3grp { /* eMMC */
                fsl,pins = <
                    MX6QDL_PAD_SD3_CMD__SD3_CMD                 0x17059
                    MX6QDL_PAD_SD3_CLK__SD3_CLK                 0x10059
                    MX6QDL_PAD_SD3_DAT0__SD3_DATA0              0x17059
                    MX6QDL_PAD_SD3_DAT1__SD3_DATA1              0x17059
                    MX6QDL_PAD_SD3_DAT2__SD3_DATA2              0x17059
                    MX6QDL_PAD_SD3_DAT3__SD3_DATA3              0x17059
                    MX6QDL_PAD_SD3_DAT4__SD3_DATA4              0x17059
                    MX6QDL_PAD_SD3_DAT5__SD3_DATA5              0x17059
                    MX6QDL_PAD_SD3_DAT6__SD3_DATA6              0x17059
                    MX6QDL_PAD_SD3_DAT7__SD3_DATA7              0x17059
                    MX6QDL_PAD_SD3_RST__SD3_RESET               0x17059
                >;
        };

        pinctrl_usbotg: usbotggrp {
                fsl,pins = <
                    MX6QDL_PAD_EIM_D21__GPIO3_IO21              0x1b0b0 /* USB_OTG_OCn */
                    MX6QDL_PAD_EIM_D22__GPIO3_IO22              0x1b0b0 /* USB_OTG_PWR */
                    MX6QDL_PAD_GPIO_1__USB_OTG_ID               0x17059 /* USB_OTG_ID */
                >;
        };

        pinctrl_pwm1: pwm1grp { fsl,pins = < MX6QDL_PAD_SD1_DAT3__PWM1_OUT    0x1b0b0 >; };
        pinctrl_pwm2: pwm2grp { fsl,pins = < MX6QDL_PAD_SD1_DAT2__PWM2_OUT    0x1b0b0 >; };
};

/ {
        aliases {
                mmc0 = &usdhc3;
        };

        regulators {
                compatible = "simple-bus";
                #address-cells = <1>;
                #size-cells = <0>;

                reg_usbotg_vbus: regulator@0 {
                        compatible = "regulator-fixed";
                        reg = <0>;
                        regulator-name = "usb_otg_vbus";
                        regulator-min-microvolt = <5000000>;
                        regulator-max-microvolt = <5000000>;
                        gpio = <&gpio3 22 GPIO_ACTIVE_HIGH>;
                        enable-active-high;
                };
/*
                reg_eth_swh_pwr: regulator@1 {
                        compatible = "regulator-fixed";
                        reg = <1>;
                        regulator-name = "eth_pwr_en";
                        regulator-min-microvolt = <5000000>;
                        regulator-max-microvolt = <5000000>;
                        gpio = <&gpio1 2 GPIO_ACTIVE_HIGH>;
                        regulator-always-on;
                        enable-active-high;
                };
*/
                reg_ser_pwr: regulator@2 { /* for RS485 transceiver */
                        compatible = "regulator-fixed";
                        reg = <2>;
                        regulator-name = "ser_pwr_en";
                        regulator-min-microvolt = <5000000>;
                        regulator-max-microvolt = <5000000>;
                        gpio = <&gpio1 6 GPIO_ACTIVE_HIGH>;
                        regulator-always-on;
                        enable-active-high;
                };
        };
};

/* disable dvfs as it appears to be causing linux hang after boot */
&busfreq {
    status = "disabled";
};

&fec {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_enet>;
        phy-mode = "rgmii";
        phy-reset-gpios = <&gpio1 3 GPIO_ACTIVE_HIGH>;
        phy-reset-duration = <2>;
        /* phy-supply = <&reg_eth_swh_pwr>; */
        fsl,magic-packet;
        status = "okay";
};

&can1 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_flexcan1>;
        status = "okay";
};

&can2 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_flexcan2>;
        status = "okay";
};

&uart1 { /* console */
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_uart1>;
        status = "okay";
};

&uart2 { /* RS485 */
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_uart2>;
        rts-gpios = <&gpio3 25 GPIO_ACTIVE_HIGH>; /* RS485_DE */
        /* RS485_REn is set to low in uboot i.e we are always receive ready */
        linux,rs485-enabled-at-boot-time;
        rs485-rx-during-tx;
        status = "okay";
};

&usbotg {
        vbus-supply = <&reg_usbotg_vbus>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_usbotg>;
        disable-over-current;
        srp-disable;
        hnp-disable;
        adp-disable;
        status = "okay";
};

&usdhc3 {  /* eMMC */
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_usdhc3>;
        bus-width = <8>;
        non-removable;
        no-1-8-v;
        keep-power-in-suspend;
        status = "okay";
};

&ecspi1 {
        fsl,spi-num-chipselects = <1>;
        cs-gpios = <&gpio4 9 0>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_ecspi1>;
        status = "okay";
        /* appears no driver for ADS114S08B RTD */
        spidev0: spi@0 {
                compatible = "rohm,dh2228fv"; /* just to disable boot warning from spidev driver */
                reg = <0>;
                spi-max-frequency = <10000000>; /* 10Mhz, not sure if this is correct for ADS114 */
        };
};

&i2c1 {
        clock-frequency = <100000>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_i2c1>;
        status = "okay";

        pbc_pcb_sensor: tc74@4d {
                compatible = "tc74";
                reg = <0x4d>;
        };

        eeprom: eeprom@50 {
                compatible = "microchip,24c16";
                reg = <0x50>;
                pagesize = <16>;
        };

        /* tilt sensor */
        lsm303c_acc { /* Accelerometer */
                compatible = "st,lsm303c_acc";
                reg = <0x1d>;
        };
        lsm303c_mag { /* Magnetometer */
                compatible = "st,lsm303c_mag";
                reg = <0x1e>;
        };
};

&i2c2 {
        clock-frequency = <100000>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_i2c2>;
        status = "okay";

        gpio-controller@77 { /* power module interface */
                compatible = "nxp,pca9539";
                reg = <0x74>;
                gpio-controller;
                #gpio-cells = <2>;
                interrupt-parent = <&gpio1>;
                interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
        };
};

&i2c3 {
        clock-frequency = <100000>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_i2c3>;
        status = "okay";
/*
        pmic: pfuze100@08 {
                compatible = "fsl,pfuze100";
                reg = <0x08>;
        };
*/
};

&pwm1 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_pwm1>;
        status = "okay";
};

&pwm2 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_pwm2>;
        status = "okay";
};
